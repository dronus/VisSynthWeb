<!DOCTYPE  html>
<html>
<head>
  <title>NF VisSynth</title>
  <script src="glfx.js/glfx.js"></script>
  <script src="audio.js"></script>
  <script src="video.js"></script>
</head>
<body>
<!--  <canvas id=audiocanvas width=640 height=256 style="position: absolute; width: 640px; height: 256px; border: 1px solid pink;">audio test canvas</canvas> -->
  <style>
    html,body,canvas{
      width: 100%;
      height: 100%;
      padding: 0px;
      margin: 0px;
      overflow: hidden;
      background-color: #000;
    }
  </style>

  <script>
    var videoengine = VideoEngine();

    var time=0,frame_time=0; // running time
    
    var put=function(url,data){
      var xmlHttp = new XMLHttpRequest();
      xmlHttp.open('PUT',url,true);  
      xmlHttp.send(data);
    }


    // pre-rendering callback (filter setup)
    var animation=function(){

      var current_time=Date.now();
      frame_time=frame_time*0.9 + (current_time-time)*0.1;
      time=current_time;

      var effect_time=time*0.001; // 1 units per second
      videoengine.setFilter(function(canvas){chain(canvas,effect_time);});
    };
    
    // post-rendering-callback (preview setup)
    var preview_cycle=0;
    var screenshot_cycle=0;
    var preview_canvas=null;
    var after_preview=function()
    {    
      if(preview_cycle==1)
      {      
        var canvas=videoengine.canvas;
        if(!preview_canvas)
        {
          preview_canvas=document.createElement('canvas');
          preview_canvas.width=canvas.preview_width; preview_canvas.height=canvas.preview_height;
        }
        var ctx=preview_canvas.getContext('2d');
        ctx.drawImage(canvas,0,canvas.height-canvas.preview_height,canvas.preview_width,canvas.preview_height, 0, 0, canvas.preview_width,canvas.preview_height);

        put('/frame_time',""+frame_time);

        preview_cycle=2;
      }
      else if(preview_cycle==2)
      {          
        var pixels=preview_canvas.toDataURL('image/jpeg');    
        put('/preview',pixels);
      
        preview_cycle=0;
      }     
    }
    // drawing finished callback    
    var after_draw=function()
    {    
      if(screenshot_cycle==1)
      {      
        var pixels=videoengine.canvas.toDataURL('image/jpeg');    
        put('/screenshot',pixels);
        screenshot_cycle=0;
      }
    }

    // install all three callbacks    
    videoengine.setCallback(animation,after_preview,after_draw);

    // append the videoengine canvas to the view
    document.body.appendChild(videoengine.canvas);

    // command polling from remote control server
    var poll_command=function()
    {
      var xmlHttp = new XMLHttpRequest();
      xmlHttp.open('GET', '/command', true);
      xmlHttp.onreadystatechange = function () {
        if (xmlHttp.readyState == 4) {
          setTimeout(function(){
            poll_command();
          },100);
          var js=xmlHttp.responseText;
          if(js) 
          {
            var result=window.eval(js);
            if(result){
              put('/result',JSON.stringify(result));
            }
          }
        }
      };
      xmlHttp.send(null);
    }
    poll_command();


    // helper functions for chain code generation

    // flatten tree-like objects values into single array, dropping keys
    var flatten=function(o){
      var a=[];
      for(var key in o) 
        if(key!='type') 
        {
          var value=o[key];
          if(typeof(value)=='object')
            a=a.concat(generators[value.type](value));
          else
            a.push(value);
        }
      return a;
    }
    // effect argument value generators...
    var generators={
      perspective:function(args){delete args.type; return ["[-0.75,-0.75, -0.75,0.75, 0.75,-0.75, 0.75,0.75],["+flatten(args).join(',')+"],true"]},
      osc:function(args){return [args.a+"*Math.sin(t*"+args.f+"+"+args.p+")+"+args.o]},
      pos:function(args){return [args.x+"+w/2",args.y+"+h/2"]},
      beat:function(args){return["audio_engine.beatValue("+flatten(args).join(',')+")"]},
      size:flatten,
      rgb:flatten,
      rgba:flatten,
      rgb_range:flatten
    };

    // generate a single effect function call source code
    var generate_code=function(effect)
    {
      var command=effect.effect;
      var args=[];
      for(var key in effect)
      {
        if(key=='effect') continue;
        var value=effect[key];
        if(typeof(value)=='object')
          args=args.concat(generators[value.type](value));
        else
          args.push(value);
      }
      
      var src=command+'('+args.join(',')+'); ';
            
      return src;
    }

    // global functions called by remote control

    // set effect chain to render
    function setChain(effects)
    {
      effects.shift(); // remove name
      effects.unshift({'effect':'stack_prepare'});    
      effects.unshift({'effect':'capture'});
      var havePreview=false;
      for(var i=0; i<effects.length; i++)
        if(effects[i].effect=='preview')
          havePreview=true;
      if(!havePreview)
        effects.push({'effect':'preview'});
      // var effects=JSON.parse(json);
      
      // create JS chain function source code
      var src='var _=function(c,t){with(c){';
      for (var i=0; i<effects.length; i++)
        src+=generate_code(effects[i]);
      src+='}};_';

      // compile chain
      var w=videoengine.canvas.width, h=videoengine.canvas.height; // provide global values for chain functions
      chain=eval(src);
    }
    
    // receive preview request from remote       
    function preview()
    {
      // engage preview process
      preview_cycle=1;
    }
    
    // receive screenshot request from remote
    function screenshot()
    {
      // engage screenshot process
      screenshot_cycle=1;
    }
    
    // load startup chain (first one of chains.json)
    var xmlHttp = new XMLHttpRequest();
    xmlHttp.open('GET','/chains.json',false);
    xmlHttp.send(null);
    var chains=JSON.parse(xmlHttp.responseText);
    setChain(chains[0] ? chains[0] : []);
    
  </script>

</body>
</html>
